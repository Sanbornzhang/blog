---
title: 重构（速读 《重构 改善既有代码的设计》）
date: 2019/7/22
updated: 2019/10/4
sticky: 10
top: 10
categories: 
- 重构
- 重构 改善既有代码的设计
tags: 
- 重构
- 重构 改善既有代码的设计
---
# 重构
    在不改变代码的外在行为的前提下，对代码进行修改，以改进程序的内部结构。
> 重构就是在代码写好之后改进他的设计，改善代码的设计质量。
## 重构的目的
1. 使代码容易阅读
2. 所有的逻辑都只在唯一地点指定
3. 新的改动不会危及到现有行为
4. 尽可能简单表达逻辑条件
<!--more-->

## 为何重构

### 重构改进软件设计
- 重复可以改善代码的设计：  
  1. 如果没有重构，程序的设计往往会逐渐腐败变质。通常我们也可能会以短期为目的、或者是再完全理解整体设计之前，就贸然修改代码，序将逐渐失去自己的结构。越来越难通过阅读代码来理解原来的设计。
  2. 代码结构的流失是基类性的，越难看都过的设计意图，就越难保护其中的设计，于是代码就腐败的越快。经常性的重构代码有助于帮助代码维持自己该有的形态。
- 消除重复的代码：
  1.  完成同样一件事，设计不良的程序往往需要修改更多的代码。这常常是因为代码在不同的地方使用完全相同的语句做同样的事情。因此改善设计的一个重要的方向就是消除重复的代码。
  2.  代码量减少并不会使系统运行的更快，但是在将来我们修改的时候，会**大大节约**修改时间。
  3.  代码量越多就越不利于修改，因为有更多的代码需要理解。你可能需要修改很多次才能达到预期的效果，而且也不利于测试的进行。
  4.  如果消除重复代码，你就可以确定所有的事物和行为在代码中之表述一次，这正是优秀设计的根本
- 让代码变得更易于理解
  > 对代码进行适当的修改，使他变得容易理。重构可以帮助我们让代码更易读。因为你的代码不仅仅是写给将计算机看的，你的代码还有其他的读者。如果几个月以后有另一位程序员尝试读懂你的代码并作出一些修改。我们很容易忘记第二位读者，但是他才是最重要的。如果其他程序员需要花费1周来读懂你所写的代码，那是不是十分糟糕呢？如果他了解了你所写的代码，这个时间可能只需要1个小时或者更少。
- 重构帮我们理解不熟悉的代码
  重构能够协助我们理解不熟悉的代码。当我们看见不熟悉的代码时，我们必须先看几行然后慢慢理解。但是有了重构我们可以修改代码，更好的反映出我们的理解，然后重新执行。这样可以帮助我们理解代码的逻辑【一般逻辑不清楚的代码、看着很吃力的代码，很可能就需要重构了， 因为代码更多的是写给人看的】，随着我们对代码做出的修改我们可能会看到一些以前看不到的设计层面上的一些东西。

### 重构帮助我们**找到BUG**
  对于代码的理解，可以帮助我们找到BUG。BUG的存在很大部分是因为逻辑不清楚造成的。而重构能够帮助我们理清代码逻辑。

### 重构提高编程速度
  重构可以改善代码的的设计，当有良好的设计之后，我们的开发就变得快速起来了。如果没有良好的设计，或许在某一段时间中我们的进展迅速，但是糟糕的设计很快就让我们开发速度降下来了，并且会花费更多的时间去调试、去理解代码的逻辑、修改重复性的代码、没有使用的代码。随着打上了越来越多的补丁，新的功能需要更多的代码实现、或者是更多的重复代码。最终造成恶性循环。
> 良好的设计才是维持原件开发速度的根本，重构可以改善既有代码的设计质量，阻止系统腐败变质、使代码变得更容易理解。 所以能够帮我们更快的开发软件

## 什么时候进行重构
   事不过三，三则重构
> 第一次去做某件事事情的时候只管去做，第二次做类似事情时会产生反感，单无论如何还是可以去做。第三次再做的时候，你就应该重构

### 添加功能时进行重构
1. 为了帮助我理解需要修改的代码
2. 原有设计无法满足当前需求，使用新的设计方式，添加功能会更加简单

### 修改错误时进行重构
    代码可读性比较低的时候,从某种角度上来说：代码可读性低，也可能是造成BUG的原因之一。

### Code Review 时
    重构可以帮助我们阅读别人的代码，代码逻辑更熟悉，也会提出更好的建议，以及更高层级的见解。并且能够得到更具体的结果(我们不仅提出建议，并且能够立即实现)

### 为什么重构有用
  程序有2面价值：
   1. 今天可以为你做什么
   2. 明天可以为你做什么  

  很多时候我们都只关注今天需要让程序做什么，无论是修复错误和添加需求。我们都是让程序能力更强，让他在今天更有价值。

但是程序当前的能力，只是整个生命周期的一部分。 如果我们为了完成当下的任务**不择手段**，，那么很可能会导致在将来的某一天不能完成任务，那么最终还是会失败。
我们可能会对当前的工作了然于心，但是未来呢？ 也许可能？
重构是一条能够解决这个问题的方法，因为我们不可能对于未来预测的尽善尽美。而且最开始预料太多，也就会导致**过度优化**的问题，并且实际的业务需求并没有考虑到。 到时候直接修改就好了，但是如果你写的代码
1. 难以阅读
2. 逻辑重复
3. 添加新行为需要修改现有代码，并且难以修改
4. 带有复杂条件逻辑，并且难以修改。  

这样对后续的修改，开发造成很大的影响。所以我们希望程序：
* 易于阅读
* 所有逻辑都在唯一地方指定
* 新的改动不会修改现有程序行为
* 尽肯能简单的表达条件逻辑  

重构就是这样的一份过程： 他在一个目前**可运行**，在不改变程序的行为的前提下使其具有上述好的品质，使我们能够高速开发，从而增加程序价值。

## 间接层和重构

#### 间接层的价值
1. 允许逻辑共享
2. 分开解释意图和实现
3. 隔离变换
4. 封装条件逻辑

## 重构的方法
1. 提取函数( 单一原则，封装)
2. 修改命名方式(好的代码应该所见即所得！)
3. 查看函数位置是否正确，如果在一个类中的`Function`，并没有使用这个类，而是使用了其他类，那么是不是应该放在其他的类中？

## 可以重构的一些代码
- 重复的代码
  1. 最简单的重复代码就是 “同一段代码块中含有相同的表达式”，这时候需要做的是，将重复的代码提炼出来，在对应的地方去调用就可以了。
  2. 如果两处地方出现了重复的代码，那我们可以吧对应的方法提到公共类中就好了。
- 过长的函数  
  * 过长的函数不利于我们的理解，我们应该积极地去拆分函数。每当我们感觉需要用注释来说明一段代码的用处的时候，很可能我们就需要把这段代码放进一个私有的函数中，并且以函数的用途来命名。这样我们就可以通过阅读函数名称知晓这段代码的作用了。  
  * 哪些是可以被提炼的  
    1. 注释 
    2. 条件表达式
    3. 循环
- 过大的类
- 过长的参数列： 在有必要的情况下，使用对象传参。[确保函数的单一性]
- 发散模式变化（开闭原则？）： 让软件更易于修改  
  当我们修改一个特性时，我们需要在很多地方修改。为此我们应该找出特定原因，并且把他提炼到对应的`函数/类`中
- 霰弹式修改： 每当遇到某种状态时，需要在许多不同的地方修改  
  这个时候我们可能需要把对应的函数放在同一个类或者文件中
- 依恋情结： 函数放的位置有问题，函数对某个类的需求高于函数所放的类中，这个时候应该把函数移到对应的类中。
- 数据泥团： 不同的类中含有多个相同的字段相同的参数，这个时候应该把它们提炼到对应的类，或者函数中。
- 基本类型偏执： 有的时候我们该使用新的小对象的时候就应该使用，不要因为事情很小就避免去使用。
- switch语句: 少使用switch语句，switch语句的问题是在于重复，很多时候为了添加新的switch语句。我们不得不找到所有的switch语句并且修改他们。很多时候我们可以用多态或者是对象去代替他。
- 平行继承体系： 如果为了当前的类新增子类的时候，也必须为另外的一个类新增子类。我们就可以让一个继承体系的实例引用另一个继承体系的子类，然后在移动对应的方法和字段，我们就可以解决这个问题。
- 冗赘类： 没有必要存在的类，大多时候是因为需求变更导致的。
- 夸夸其谈的未来性： 当有的代码是为了未来某一天去做什么事情的时候，并且添加了各种各样的Hook或者来处理一些非必要的事情的时候。这么做了反而会造成系统的更加难以理解与维护。如过是抽象的类和方法，那么就合并他。如果是多余的参数那么久去除掉就可以了。
- 令人迷惑的暂时字段： 某个实例的某个变量只是为了某种特定情况设置的。这样的代码让人不利于理解。 这种情况把对应的变量和代码提成一个类。[但是有的是设计不当造成的]
- 过度耦合的消息链：有的时候我们看到的是一个方法请求另一个方法的方法 `Person.find('san').getDepartment().getManager()` 我们应该改为 `san.getManager()`. 因为调用链过长会导致我们后续的修改困难。
- 过多的中间函数： 如果有很多函数都`Person.find('san').getDepartment().getManager()`，那么我们就可以修改为`manager('san)`
- 狎昵关系： 类 过度的耦合,两个类都需要调用对方的私有方法。先分清到底哪个类真的需要这个方法，如果还存在的话，可以提成公有方法。 如果是继承体系的话，如果子类对超类的了解总是超过了后者的主观，那么可以让这个子类独立出去。
- 异曲同工的类： 两个类执行相同的功能，但具有不同的方法名称。根据他们的用途重新命名，并且将某些行为移到对应的类中
- 不完美的库类： 有很多时候我们使用的第三方库可能没有我们需要的功能的时候，我们可能需要一些方法去修改这个库的某些函数
- 纯稚的数据类： 数据类是指仅包含字段和用于访问它们的粗略方法（getter和setter）的类。这些只是其他类使用的数据的容器。这些类不包含任何其他功能，并且不能独立地对其拥有的数据进行操作。
- 错误的继承关系： 子类复用了超类的实现，却不愿意支持超类的接口
- 过多的注释

## 重构的列表
### 记录
    简单扼要的介绍这个重构能够帮助解决的问题，简单的介绍你要做的事情；简单的介绍重构前后的示例
1. 名称： 创建一个重构词汇表
2. 概要： 简单的介绍当前重构手法的使用场景，以及它能做的事情
3. 动机： 介绍“为什么需要重构” 以及 “什么情况下不该使用这个重构”
4. 做法： 简明扼要的一步一步介绍如何进行这个重构
5. 范例： 以一个十分简单的例子说明这个重构的手法怎么运作

## 重新组织函数

### Extract Method（提炼函数）
    你有一段代码可以被组织在一起并能独立出来，将这段代码放进一个独立的函数中，并让函数名称解释该函数的用途

#### 动机
    过长的函数或者需要一段注释才能让人看懂得代码
好处：如果每个函数的粒度都很小，那么函数被复用的机会就更大；良好的函数命名会使高层函数读起来就像是一系列的注释；如果函数都是细粒度，那么函数的复写也会更容易。

### Inline Method(内联函数)
    当方法主体比方法名称本身更为明显时，可以直接使用该函数本身
#### 动机
    虽然简短的函数利于阅读，但是有的时候我们会遇到一些函数，他的内部代码和函数名称同样清晰阅读。这样就加了一层间接性的代码，间接性的代码可能会带来帮助，但是非必要的间接性会让人觉得不舒服。
#### exp：
``` js
class PizzaDelivery {
  // ...
  getRating(): number {
    return moreThanFiveLateDeliveries() ? 2 : 1;
  }
  moreThanFiveLateDeliveries(): boolean {
    return numberOfLateDeliveries > 5;
  }
//----
class PizzaDelivery {
  // ...
  getRating(): number {
    return numberOfLateDeliveries > 5 ? 2 : 1;
  }
}
```

### Inline Temp (内联临时变量)
    你有一个临时变量，但是只被简单地赋值了一次，但是妨碍了其他的重构手法。 就讲所有对这个变量的引用动作，替换为对他赋值的表达式的本身

#### 动机
      内联局部变量几乎总是用作“ 用查询替换变量”的一部分，或为 “提取方法” 铺平道路。一般来说这样的临时变量不会有任何危害，可以放心的把他放在那，但是如果影响到其他的重构手法的时候，就可以将它内联化。
#### 案例
``` JS
hasDiscount(order: Order): boolean {
  let basePrice: number = order.basePrice();
  return basePrice > 1000;
}
// -------
hasDiscount(order: Order): boolean {
  return order.basePrice() > 1000;
}
```
### Replace Temp with Query (以查询替代临时变量)
     你的代码中有一个临时变量保存的是一个表达式的运算结果，那么可以将这个表达式提取到一个独立的函数中，将这个临时变量的所有引用替换为函数的调用。
#### 动机
    临时变量的问题在于： 他们是暂时的，而且只能在所属的函数内使用。如果变成一个函数，那么你在整个类中就可以看到整个函数。
> 更觉得是因为在同一个类中使用多个相同的临时变量，或者是相同的表达式。那么就可以提取出来。  
#### 例子
```js
 calculateTotal(): number {
  let basePrice = quantity * itemPrice;
  if (basePrice > 1000) {
    return basePrice * 0.95;
  }
  else {
    return basePrice * 0.98;
  }
}
// ---
calculateTotal(): number {
  if (basePrice() > 1000) {
    return basePrice() * 0.95;
  }
  else {
    return basePrice() * 0.98;
  }
}
basePrice(): number {
  return quantity * itemPrice;
}
```

### Introduce Explaining Variable（引入临时解释性变量）
    你有一个很复杂的表达式，将该表达式的一部分或者整个表达式放进一个临时变量中，以变量名来解释表达式用途

#### 动机
    表达式可能很复杂，非常难以阅读

#### 例子
```js
renderBanner(): void {
  if ((platform.toUpperCase().indexOf("MAC") > -1) &&
       (browser.toUpperCase().indexOf("IE") > -1) &&
        wasInitialized() && resize > 0 )
  {
    // do something
  }
}
// ---
renderBanner(): void {
  const isMacOs = platform.toUpperCase().indexOf("MAC") > -1;
  const isIE = browser.toUpperCase().indexOf("IE") > -1;
  const wasResized = resize > 0;

  if (isMacOs && isIE && wasInitialized() && wasResized) {
    // do something
  }
}
```

### Split Temporary Variable(分解临时变量)
    你的程序中含有临时变量，摈弃被赋值超过一次，他既不是循环变量，也不被用于收集计算的结果。
    针对每次赋值，创建一个独立、对应的临时变量。

#### 动机
    由于错误的使用了临时变量（不相关的目的重复使用），那么在修改变量的代码出现问题时，必须检查每种变量的使用情况。
    单一原则，会使代码的维护变得更加容易，良好的变量名会使代码更具可读性。

#### 例子

```js
let temp = 2 * (height + width);
console.log(temp);
temp = height * width;
console.log(temp);
// ---

const perimeter = 2 * (height + width);
console.log(perimeter);
const area = height * width;
console.log(area);
```

### Remove Assignments to Parameters(移除对参数的赋值)
    代码对参数进行赋值，以一个临时变量取代该操作

#### 动机
     如果参数是一个对象时，有的语言是按照 引用传递的时候，我们在修改参数内部时候，也会对其他调用的地方进行修改，在有的时候会导致很难去查询这个问题

#### 例子
```js
discount(inputVal: number, quantity: number): number {
  if (inputVal > 50) {
    inputVal -= 2;
  }
  // ...
}
// ---
discount(inputVal: number, quantity: number): number {
  let result = inputVal;
  if (inputVal > 50) {
    result -= 2;
  }
  // ...
}
```

### Replace Method with Method Object (以函数对象取代函数)
    你有一个很长的一个方法，但是之间的局部变量很多，导致没办法提取为一个新的方法。
    将该方法转换为一个单独的类，将局部变量成为该方法的字段。然后将方法拆分为同一个类中的多个方法。

#### 动机
      方法太长，并且由于难以隔离的大量局部变量，无法将其分开。

#### 例子
```js
class Order {
  // ...
  price(): number {
    let primaryBasePrice;
    let secondaryBasePrice;
    let tertiaryBasePrice;
    // Perform long computation.
  }
}
// ---
class Order {
  // ...
  price(): number {
    return new PriceCalculator(this).compute();
  }
}

class PriceCalculator {
  private _primaryBasePrice: number;
  private _secondaryBasePrice: number;
  private _tertiaryBasePrice: number;
  
  constructor(order: Order) {
    // Copy relevant information from the
    // order object.
  }
  
  compute(): number {
    // Perform long computation.
  }
}
```

### Substitute Algorithm（替换算法）
    你想要将某个算法替换为一个很清晰的算法。直接将函数本体替换为另外一个算法。

#### 动机
    发现一个比原有算法更好的算法的时候

#### 例子
``` js
foundPerson(people: string[]): string{
  for (let person of people) {
    if (person.equals("Don")){
      return "Don";
    }
    if (person.equals("John")){
      return "John";
    }
    if (person.equals("Kent")){
      return "Kent";
    }
  }
  return "";
}
// ---
foundPerson(people: string[]): string{
  let candidates = ["Don", "John", "Kent"];
  for (let person of people) {
    if (candidates.contains(person)) {
      return person;
    }
  }
  return "";
}
```
