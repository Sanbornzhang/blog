# Redis
## 一致性问题
1. 读请求，先读缓存，如果没有命中，读数据库，再set回缓存
2. 写请求  
     - 先缓存，再数据库
     - 缓存，使用delete，而不是set[先删除缓存，并且设置缓存锁，等到数据库更新更新成功以后取消锁，所需要设置过期时间以防死锁的发生]
## 缓存穿透
    缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。
### 解决:
      空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。
## 缓存雪崩
    缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。
### 解决:
    设置不同的过期时间，如果业务上量很大的时候加上随机时间作为过期时间。
## 缓存击穿
      热Key在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。
### 解决:
互斥锁:
 当值为空时: 使用 `redis.setnx` 使用 `redis.setnx` 看是否成功 如果成功则去重新刷新缓存，否则重试获取缓存方法。  
 当然为了防止死锁要对 `setnx` 设置过期时间，成功取到值以后需要删除。
## 持久化
### RDB
RDB: 持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。
- 优点
  1. RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。
  2. RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。
- 缺点
  1. 会丢失数据
  2. 数据量大的时候 `fork()` 会非常耗时
### AOF
AOF: 将redis执行过的所有写指令记录下来.
- 优点
  1. AOF 的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据。
  2. AOF 文件是一个只进行追加操作的日志文件（append only log）， 因此对 AOF 文件的写入不需要进行 seek ， 即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满，写入中途停机，等等）， redis-check-aof 工具也可以轻易地修复这种问题。
  3. redis提供了AOF文件重写（rewrite）机制，即当AOF文件的大小超过所设定的阈值时，redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。
  4. AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 
- 缺点
  1. AOF文件要比RDB文件的体积大。
  2. AOF方式的恢复速度也要慢于RDB方式。
### RDB or AOF
both！

## 淘汰策略
## REF:
[一份完整的阿里云 Redis 开发规范](https://mp.weixin.qq.com/s/dUfkS3ijfxSlRuJPZ9B01A)
<!-- [Redis百亿级Key存储方案](http://www.cnblogs.com/colorfulkoala/p/5783556.html) -->
[缓存与数据库不一致，咋办？](https://mp.weixin.qq.com/s/gYQvP69sao8U0azuNRMG1w)
[redis4.0之RDB-AOF混合持久化](https://yq.aliyun.com/articles/193034)